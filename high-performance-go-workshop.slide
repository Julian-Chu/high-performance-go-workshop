High Performance Go Workshop
Mercari
11 Apr 2018

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* License and Materials

This presentation is licensed under the [[https://creativecommons.org/licenses/by-sa/4.0/][Creative Commons Attribution-ShareAlike 4.0 International]] licence.

The materials for this presentation are available on GitHub:

.link https://github.com/davecheney/high-performance-go-workshop

You are encouraged to remix, transform, or build upon the material, providing you give appropriate credit and distribute your contributions under the same license.

If you have suggestions or corrections to this presentation, please raise [[https://github.com/davecheney/high-performance-go-workshop/issues][an issue on the GitHub project]].

* Prerequisites

- Go 1.10 installed on your laptop. Earlier versions of Go ship with earlier versions of the profiling and tracing tools, please make sure you have Go 1.10 or things won't make sense.
- Graphviz. The pprof tool requires the `dot` program which ships with the `graphviz` suite of tools. 

Linux: 

 [sudo] apt-get install graphviz

OSX:

MacPorts:

 sudo port install graphviz

Homebrew:

 brew install graphviz

* Agenda

This workshop is aimed at development teams who are building production Go applications intended for high scale deployment.

The plan is to work from profiling and benchmarking of functions to profiling and optimising a full concurrent program.

- Introduction
- [[01-profiling/profiling.slide][Performance measurement and profiling]]
- [[02-benchmarking/benchmarking.slide][Benchmarking]]
- profile whole programs; github.com/pkg/profile
- [[03-compiler-optimisations/compiler-optimisations.slide][Compiler optimisations]]
- [[04-execution-tracer/understanding-the-execution-tracer.slide][Understanding the execution tracer]]
- Memory management and GC tuning
- Concurrency
- Conclusion

After each section we'll have time for questions.

* One more thing ...

This isn't a lecture, it's a conversation.

We'll have lots of breaks to ask questions.

If you don't understand something, or think what you're hearing is incorrect, please ask.

* Introduction

* Two questions>

Before we talk about writing high performance code, we need to talk about the hardware that will execute this code.

What are its properties and how have they changed over time?

As software authors we have benefited from Moore's Law, the doubling of the number of available transistors on a chip every 18 months, for 50 years.

No other industry has experienced a _six_order_of_magnitude_ improvement in their tools in the space of a lifetime.

But this is all changing.

* The CPU

.image images/cpu.svg _ 600

The number of transistors per CPU die continues to increase.

However clock speeds have not increased in a decade, and transistors per dollar has started to fall.

* More cores

.image images/Nehalem_Die_Shot_3.jpg _ 600

Over the last decade performance, especially on the server, has been dictated by adding more CPU cores.

CPU core count is dominated by heat dissipation and cost.

* Transistor size reductions have run out of steam

.image images/Mjc5MTM2Nw.png _ 580

Shrinking the size of a transistor, to fit more in the same sized die, is hitting a wall.

CPU dies can be made larger, but that increases latency, and cost per transistor.

* Modern CPUs are optimised for bulk transfers

"Modern processors are a like nitro fueled funny cars, they excel at the quarter mile. Unfortunately modern programming languages are like Monte Carlo, they are full of twists and turns."
.caption David Ungar, OOPSLA (year unknown)

# https://youtu.be/4LG-RtcSYUQ?t=39m59s

Much of the improvement in performance in the last two decades has come from architectural improvements:

- out of order execution (super-scalar)
- speculative execution
- vector (SSE) instructions

Thus, modern CPUs are optimised for bulk transfers and bulk operations. At every level, the setup cost of an operation encourages you to work in bulk.

e.g. memory is not loaded per byte, but per multiple of cache lines, this is why alignment is becoming less of an issue. 

* Memory

Physical memory attached to a server has increased geometrically.

.image images/latency.png _ 600

But, in terms of processor cycles lost, physical memory is still as far away as ever.

* Cache rules everything around it

.image images/xeon_e5_v4_hcc_rings.jpg _ 600

Cache rules everything around it, but it is small, and will remain small because the speed of light determines how large a cache can be for a certain latency.

You can have a larger cache, but it will be slower because, in a universe where electricity travels a foot every nanosecond, distance equals latency.

* Network and disk I/O are still expensive

Network and disk I/O are still expensive, so expensive that the Go runtime will schedule something else while those operations are in progress.

.image images/media-20160803.jpg

* The free lunch is over

In 2005 Herb Sutter, the C++ committee leader, wrote an article entitled [[http://www.gotw.ca/publications/concurrency-ddj.htm][_The_free_lunch_is_over_]].

In his article Sutter discussed all the points I covered and asserted that programmers could no longer rely on faster hardware to fix slow programsâ€”or slow programming languages.

Now, a decade later, there is no doubt that Herb Sutter was right. Memory is slow, caches are too small, CPU clock speeds are going backwards, and the simple world of a single threaded CPU is long gone.

* A fast programming language

It's time for the software to come to the party.

As [[https://www.youtube.com/watch?v=aiv1JOfMjm0][Rick Hudson noted at GopherCon]] in 2015, it's time for a programming language that works _with_ the limitations of today's hardware, rather than continue to ignore the reality that CPU designers find themselves.

So, for best performance on today's hardware in today's world, you need a programming language which:

- Is compiled, not interpreted.
- Permits efficient code to be written.
- Lets programmers talk about memory effectively, think structs vs java objects
- Has a compiler that produces efficient code, it has to be small code as well, because cache.

Obviously the language I'm talking about is the one we're here to discuss: Go.

* Discussion

Discussion:

- Do you agree that computers are no longer getting faster?

- Do you think we need to change languages to take advantage of modern hardware?

Further reading

.link https://www.youtube.com/watch?v=rKnDgT73v8s The Go Programming language (Nov 10, 2009)
.link https://www.youtube.com/watch?v=5kj5ApnhPAE OSCON 2010: Rob Pike, "Public Static Void"

* Next

[[01-profiling/profiling.slide][Performance measurement and profiling]]

